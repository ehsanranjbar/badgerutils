package ref

import (
	"bytes"
	"fmt"
	"math"

	"github.com/dgraph-io/badger/v4"
	"github.com/ehsanranjbar/badgerutils"
	"github.com/ehsanranjbar/badgerutils/iters"
	pstore "github.com/ehsanranjbar/badgerutils/store/prefix"
)

type Store struct {
	base   badgerutils.Instantiator[badgerutils.BadgerStore]
	prefix []byte
}

func New(base badgerutils.Instantiator[badgerutils.BadgerStore]) *Store {
	var prefix []byte
	if pfx, ok := base.(prefixed); ok {
		prefix = pfx.Prefix()
	}

	return &Store{
		base:   base,
		prefix: prefix,
	}
}

type prefixed interface {
	Prefix() []byte
}

func (s *Store) Prefix() []byte {
	return s.prefix
}

func (s *Store) Instantiate(txn *badger.Txn) badgerutils.StoreInstance[
	[]byte,
	[]byte,
	RefEntry,
	badgerutils.Iterator[[]byte, []byte],
] {
	var base badgerutils.BadgerStore = txn
	if s.base != nil {
		base = s.base.Instantiate(txn)
	}

	return &Instance{
		base:   base,
		prefix: s.prefix,
	}
}

// RefEntry is an index that is generated by an Indexer
type RefEntry struct {
	Prefix        []byte
	OptionalValue []byte // Value stored as the value of index record that can be used in index only queries
}

// NewRefEntry creates a new RefEntry
func NewRefEntry(prefix []byte) RefEntry {
	return RefEntry{
		Prefix: prefix,
	}
}

// WithValue sets the value of the RefEntry
func (e RefEntry) WithValue(value []byte) RefEntry {
	e.OptionalValue = value
	return e
}

// Instance is a store that works with serialized values and also keeps track of multiple secondary indexes.
type Instance struct {
	base   badgerutils.BadgerStore
	prefix []byte
}

// Prefix returns the prefix of the store.
func (s *Instance) Prefix() []byte {
	return s.prefix
}

// Delete deletes all items from the store that have the given prefix
func (s *Instance) Delete(prefix []byte) error {
	iter := s.base.NewIterator(badger.IteratorOptions{
		Prefix:         prefix,
		PrefetchValues: false,
	})
	defer iter.Close()

	for iter.Rewind(); iter.Valid(); iter.Next() {
		err := s.base.Delete(bytes.TrimPrefix(iter.Item().Key(), s.prefix))
		if err != nil {
			return err
		}
	}
	return nil
}

// Get gets a Ref given its whole key
func (s *Instance) Get(prefix []byte) ([]byte, error) {
	_, key, err := s.GetWithItem(prefix)
	return key, err
}

// GetWithItem gets a Ref given its whole key and also returns the *badger.Item
func (s *Instance) GetWithItem(prefix []byte) (*badger.Item, []byte, error) {
	iter := s.base.NewIterator(badger.IteratorOptions{
		Prefix:         prefix,
		PrefetchValues: false,
	})
	defer iter.Close()

	item, err := iters.FirstItem(iter)
	if err != nil {
		return nil, nil, err
	}

	key := extractKey(item.Key(), item.UserMeta())
	return item, key, nil
}

func extractKey(bz []byte, keyLen uint8) []byte {
	return bz[len(bz)-int(keyLen):]
}

// Set sets a Ref in the store
func (s *Instance) Set(key []byte, e RefEntry) error {
	if len(key) > math.MaxUint8 {
		return fmt.Errorf("key is too long")
	}

	item := badger.NewEntry(append(e.Prefix, key...), e.OptionalValue).WithMeta(uint8(len(key)))
	return s.base.SetEntry(item)
}

// NewIterator creates a new reference iterator
func (s *Instance) NewIterator(opts badger.IteratorOptions) badgerutils.Iterator[[]byte, []byte] {
	var iter badgerutils.BadgerIterator = s.base.NewIterator(opts)
	if s.prefix != nil {
		iter = pstore.NewIterator(iter, s.prefix)
	}

	return newIterator(iter)
}
