package ref

import (
	"fmt"
	"math"
	"time"

	"github.com/dgraph-io/badger/v4"
	"github.com/ehsanranjbar/badgerutils"
	"github.com/ehsanranjbar/badgerutils/iters"
)

// Ref is a reference to a key in the store.
type Ref struct {
	Prefix []byte
	Key    []byte
}

// RefEntry is an index that is generated by an Indexer
type RefEntry struct {
	Prefix        []byte
	OptionalValue []byte // Value stored as the value of index record that can be used in index only queries
	TTL           time.Duration
}

// NewRefEntry creates a new RefEntry
func NewRefEntry(prefix []byte) RefEntry {
	return RefEntry{
		Prefix: prefix,
	}
}

// WithValue sets the value of the RefEntry
func (e RefEntry) WithValue(value []byte) RefEntry {
	e.OptionalValue = value
	return e
}

// WithTTL sets the TTL of the RefEntry
func (e RefEntry) WithTTL(ttl time.Duration) RefEntry {
	e.TTL = ttl
	return e
}

// Store is a store that works with serialized values and also keeps track of multiple secondary indexes.
type Store struct {
	base badgerutils.BadgerStore
}

// New creates a new RefStore
func New(base badgerutils.BadgerStore) *Store {
	return &Store{
		base: base,
	}
}

// Delete deletes all items from the store that have the given prefix
func (s *Store) Delete(prefix []byte) error {
	iter := s.base.NewIterator(badger.IteratorOptions{
		Prefix:         prefix,
		PrefetchValues: false,
	})
	defer iter.Close()

	for iter.Rewind(); iter.Valid(); iter.Next() {
		err := s.base.Delete(iter.Item().Key())
		if err != nil {
			return err
		}
	}
	return nil
}

// Get gets a Ref given its whole key
func (s *Store) Get(prefix []byte) (*Ref, error) {
	_, ref, err := s.GetWithItem(prefix)
	return ref, err
}

// GetWithItem gets a Ref given its whole key and also returns the *badger.Item
func (s *Store) GetWithItem(prefix []byte) (*badger.Item, *Ref, error) {
	iter := s.base.NewIterator(badger.IteratorOptions{
		Prefix:         prefix,
		PrefetchValues: false,
	})
	defer iter.Close()

	item, err := iters.FirstItem(iter)
	if err != nil {
		return nil, nil, err
	}

	prefix, key := splitKey(item.Key(), item.UserMeta())
	return item, &Ref{
		Prefix: prefix,
		Key:    key,
	}, nil
}

func splitKey(key []byte, keyLen uint8) (prefix, k []byte) {
	return key[:len(key)-int(keyLen)], key[len(key)-int(keyLen):]
}

// NewIterator creates a new reference iterator
func (s *Store) NewIterator(opts badger.IteratorOptions) badgerutils.Iterator[[]byte] {
	return &refIterator{
		base: s.base.NewIterator(opts),
	}
}

type refIterator struct {
	base *badger.Iterator
}

// Close implements the Iterator interface
func (i *refIterator) Close() {
	i.base.Close()
}

// Item implements the Iterator interface
func (i *refIterator) Item() *badger.Item {
	return i.base.Item()
}

// Next implements the Iterator interface
func (i *refIterator) Next() {
	i.base.Next()
}

// Rewind implements the Iterator interface
func (i *refIterator) Rewind() {
	i.base.Rewind()
}

// Seek implements the Iterator interface
func (i *refIterator) Seek(key []byte) {
	i.base.Seek(key)
}

// Valid implements the Iterator interface
func (i *refIterator) Valid() bool {
	return i.base.Valid()
}

// Value implements the Iterator interface
func (i *refIterator) Value() ([]byte, error) {
	item := i.base.Item()
	if item == nil {
		return nil, nil
	}

	_, key := splitKey(item.Key(), item.UserMeta())
	return key, nil
}

// Set sets a Ref in the store
func (s *Store) Set(key []byte, e RefEntry) error {
	if len(key) > math.MaxUint8 {
		return fmt.Errorf("key is too long")
	}

	item := badger.NewEntry(append(e.Prefix, key...), e.OptionalValue).WithMeta(uint8(len(key)))
	if e.TTL > 0 {
		item = item.WithTTL(e.TTL)
	}
	return s.base.SetEntry(item)
}
