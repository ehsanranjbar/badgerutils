package ref

import (
	"fmt"
	"math"
	"time"

	"github.com/dgraph-io/badger/v4"
	"github.com/ehsanranjbar/badgerutils"
	"github.com/ehsanranjbar/badgerutils/iters"
	pstore "github.com/ehsanranjbar/badgerutils/store/prefix"
)

// RefEntry is an index that is generated by an Indexer
type RefEntry struct {
	Prefix        []byte
	OptionalValue []byte // Value stored as the value of index record that can be used in index only queries
	TTL           time.Duration
}

// NewRefEntry creates a new RefEntry
func NewRefEntry(prefix []byte) RefEntry {
	return RefEntry{
		Prefix: prefix,
	}
}

// WithValue sets the value of the RefEntry
func (e RefEntry) WithValue(value []byte) RefEntry {
	e.OptionalValue = value
	return e
}

// WithTTL sets the TTL of the RefEntry
func (e RefEntry) WithTTL(ttl time.Duration) RefEntry {
	e.TTL = ttl
	return e
}

// Store is a store that works with serialized values and also keeps track of multiple secondary indexes.
type Store struct {
	base badgerutils.BadgerStore
}

// New creates a new RefStore
func New(base badgerutils.BadgerStore) *Store {
	return &Store{
		base: base,
	}
}

// Prefix returns the prefix of the store.
func (s *Store) Prefix() []byte {
	if pfx, ok := s.base.(prefixed); ok {
		return pfx.Prefix()
	}

	return nil
}

type prefixed interface {
	Prefix() []byte
}

// Delete deletes all items from the store that have the given prefix
func (s *Store) Delete(prefix []byte) error {
	iter := s.base.NewIterator(badger.IteratorOptions{
		Prefix:         prefix,
		PrefetchValues: false,
	})
	defer iter.Close()

	for iter.Rewind(); iter.Valid(); iter.Next() {
		err := s.base.Delete(iter.Item().Key())
		if err != nil {
			return err
		}
	}
	return nil
}

// Get gets a Ref given its whole key
func (s *Store) Get(prefix []byte) ([]byte, error) {
	_, key, err := s.GetWithItem(prefix)
	return key, err
}

// GetWithItem gets a Ref given its whole key and also returns the *badger.Item
func (s *Store) GetWithItem(prefix []byte) (*badger.Item, []byte, error) {
	iter := s.base.NewIterator(badger.IteratorOptions{
		Prefix:         prefix,
		PrefetchValues: false,
	})
	defer iter.Close()

	item, err := iters.FirstItem(iter)
	if err != nil {
		return nil, nil, err
	}

	key := extractKey(item.Key(), item.UserMeta())
	return item, key, nil
}

func extractKey(bz []byte, keyLen uint8) []byte {
	return bz[len(bz)-int(keyLen):]
}

// Set sets a Ref in the store
func (s *Store) Set(key []byte, e RefEntry) error {
	if len(key) > math.MaxUint8 {
		return fmt.Errorf("key is too long")
	}

	item := badger.NewEntry(append(e.Prefix, key...), e.OptionalValue).WithMeta(uint8(len(key)))
	if e.TTL > 0 {
		item = item.WithTTL(e.TTL)
	}
	return s.base.SetEntry(item)
}

// NewIterator creates a new reference iterator
func (s *Store) NewIterator(opts badger.IteratorOptions) badgerutils.Iterator[[]byte] {
	var iter badgerutils.BadgerIterator = s.base.NewIterator(opts)
	if pfx := s.Prefix(); pfx != nil {
		iter = pstore.NewIterator(iter, pfx)
	}

	return &iterator{
		base: iter,
	}
}
